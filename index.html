<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>DUNGEON</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
html,body { width:100%; height:100%; background:#000; color:#fff; font-family:'Courier New',Courier,monospace; overflow:hidden; user-select:none; }
#hud {
  position:fixed; top:0; left:0; right:0;
  display:flex; justify-content:space-between; align-items:center;
  padding:6px 18px; background:#000; border-bottom:1px solid #1a1a1a;
  font-size:12px; color:#444; z-index:10; pointer-events:none; gap:10px; flex-wrap:wrap;
}
#hud .label { color:#333; }
#hud .val   { color:#bbb; }
#hud .hp-bar {
  display:inline-block; width:90px; height:6px;
  background:#1a0000; border:1px solid #400; vertical-align:middle; margin:0 5px; position:relative;
}
#hud .hp-fill { position:absolute; top:0; left:0; bottom:0; background:#900; transition:width 0.1s; }
#hud .atk-bar {
  display:inline-block; width:50px; height:4px;
  background:#111; border:1px solid #333; vertical-align:middle; margin:0 4px; position:relative;
}
#hud .atk-fill { position:absolute; top:0; left:0; bottom:0; background:#557; }
#hud #fx-bar { display:flex; gap:5px; align-items:center; }
#hud .fx-pill { font-size:10px; padding:1px 5px; border:1px solid #333; color:#888; }
#fullscreen-btn {
  background:none; border:1px solid #333; color:#666; padding:2px 6px; 
  cursor:pointer; font-family:'Courier New'; font-size:10px; user-select:none; pointer-events:auto;
}
#fullscreen-btn:hover { color:#aaa; border-color:#555; }
#fullscreen-btn.active { color:#4a4; border-color:#4a4; }
canvas { display:block; }
#msg {
  position:fixed; bottom:0; left:0; right:0; padding:4px 18px;
  background:#000; border-top:1px solid #1a1a1a;
  font-size:11px; color:#444; z-index:10; pointer-events:none; min-height:22px;
}
#msg .hi { color:#888; }
#overlay {
  position:fixed; inset:0; background:#000;
  display:flex; flex-direction:column; align-items:center; justify-content:center;
  z-index:20; gap:1.2em;
}
#overlay .sub { color:#3a3a55; font-size:0.8em; text-align:center; font-family:'Courier New',monospace; line-height:2; }
#overlay .btn {
  font-family:'Courier New',monospace; font-size:0.95em; background:none;
  border:1px solid #333; color:#999; padding:8px 28px; cursor:pointer; letter-spacing:0.1em;
}
#overlay .btn:hover { border-color:#fff; color:#fff; }

/* ── MINIMAP ─────────────────────────────────────────── */
/* small corner minimap */
#minimap-wrap {
  position:fixed; top:34px; right:0;
  z-index:15; pointer-events:auto;
  display:flex; flex-direction:column; align-items:flex-end;
}
#minimap-toggle {
  background:#000; border:1px solid #222; border-right:none;
  color:#444; font-size:10px; padding:2px 7px; cursor:pointer;
  font-family:'Courier New',monospace; letter-spacing:.05em;
  user-select:none;
}
#minimap-toggle:hover { color:#aaa; border-color:#555; }
#minimap-canvas {
  display:block; border:1px solid #222; border-right:none; border-top:none;
  background:#000; cursor:pointer;
  image-rendering: pixelated;
}
/* fullscreen map overlay */
#map-overlay {
  position:fixed; inset:0; background:rgba(0,0,0,0.96);
  display:none; flex-direction:column; align-items:center; justify-content:center;
  z-index:25; gap:10px;
}
#map-overlay.active { display:flex; }
#map-overlay-canvas {
  display:block; image-rendering:pixelated;
  border:1px solid #333;
}
#map-overlay-label {
  color:#333; font-size:11px; letter-spacing:.15em;
  font-family:'Courier New',monospace;
}

/* ── PAUSE OVERLAY ───────────────────────────────────── */
#pause-overlay {
  position:fixed; inset:0; background:rgba(0,0,0,0.82);
  display:none; flex-direction:column; align-items:center; justify-content:center;
  z-index:30; gap:0;
}
#pause-overlay.active { display:flex; }
#pause-box {
  border:1px solid #333; padding:40px 60px;
  display:flex; flex-direction:column; align-items:center; gap:0;
  min-width:320px;
}
#pause-box .p-title { color:#666; font-size:11px; letter-spacing:.25em; margin-bottom:28px; }
.p-item {
  width:100%; padding:10px 0; cursor:pointer;
  color:#555; font-size:13px; letter-spacing:.1em;
  border-bottom:1px solid #111; text-align:left;
  display:flex; justify-content:space-between; align-items:center;
}
.p-item:last-child { border-bottom:none; }
.p-item:hover, .p-item.selected { color:#ddd; }
.p-item .key { color:#333; font-size:10px; }
.p-controls {
  margin-top:24px; padding-top:18px; border-top:1px solid #1a1a1a;
  width:100%; color:#333; font-size:10px; line-height:2.2; letter-spacing:.04em;
}
.p-controls span { color:#555; }

/* ── LEGEND PANEL ────────────────────────────────────── */
#legend-wrap {
  position:fixed; top:50%; right:0; transform:translateY(-50%);
  z-index:15; display:flex; align-items:center; pointer-events:auto;
}
#legend-tab {
  writing-mode:vertical-rl; text-orientation:mixed;
  background:#000; border:1px solid #222; border-right:none;
  color:#444; font-size:10px; padding:8px 4px; cursor:pointer;
  font-family:'Courier New',monospace; letter-spacing:.1em;
  user-select:none; transform:rotate(180deg);
}
#legend-tab:hover { color:#aaa; border-color:#555; }
#legend-panel {
  background:#000; border:1px solid #222; border-right:none;
  width:0; overflow:hidden;
  transition:width .2s;
  height:auto; max-height:calc(100vh - 80px);
  overflow-y:auto; overflow-x:hidden;
}
#legend-panel.open { width:220px; }
#legend-inner { padding:12px 14px; min-width:220px; }
#legend-inner .l-title { color:#333; font-size:10px; letter-spacing:.2em; margin-bottom:12px; border-bottom:1px solid #1a1a1a; padding-bottom:6px; }
.l-entry { margin-bottom:14px; border-bottom:1px solid #0e0e0e; padding-bottom:10px; }
.l-entry:last-child { border-bottom:none; margin-bottom:0; }
.l-entry .l-head { display:flex; align-items:center; gap:8px; margin-bottom:4px; }
.l-entry .l-ch { font-size:16px; font-weight:bold; width:18px; text-align:center; }
.l-entry .l-name { font-size:12px; color:#aaa; letter-spacing:.06em; }
.l-entry .l-stats { font-size:10px; color:#444; line-height:1.9; }
.l-entry .l-stats span { color:#666; }
.l-entry .l-flavor { font-size:10px; color:#333; margin-top:3px; font-style:italic; }
</style>
</head>
<body>
<div id="hud">
  <div><span class="label">DUNGEON</span> &nbsp;<span class="val" id="h-floor">Floor 1</span></div>
  <div>
    <span class="label">HP</span>
    <span class="hp-bar"><span class="hp-fill" id="h-hp" style="width:100%"></span></span>
    <span class="val" id="h-hpnum">10/10</span>
  </div>
  <div>
    <span class="label">ATK</span>
    <span class="atk-bar"><span class="atk-fill" id="h-atk" style="width:0%"></span></span>
  </div>
  <div><span class="label">WPN</span> &nbsp;<span class="val" id="h-wpn">fists</span></div>
  <div id="fx-bar"></div>
  <div><span class="label">KILLS</span> <span class="val" id="h-kills">0</span> &nbsp; <span class="label">SCORE</span> <span class="val" id="h-score">0</span></div>
  <div><span class="label">FULLSCREEN</span> <button id="fullscreen-btn">[F]</button></div>
</div>
<canvas id="c"></canvas>
<div id="msg"><span id="msg-text"></span></div>

<!-- MINIMAP (corner) -->
<div id="minimap-wrap">
  <div id="minimap-toggle">MAP [M]</div>
  <canvas id="minimap-canvas" width="120" height="120"></canvas>
</div>

<!-- FULLSCREEN MAP OVERLAY -->
<div id="map-overlay">
  <canvas id="map-overlay-canvas"></canvas>
  <div id="map-overlay-label">[ M ] or [ ESC ] to close</div>
</div>

<!-- PAUSE OVERLAY -->
<div id="pause-overlay">
  <div id="pause-box">
    <div class="p-title">— PAUSED —</div>
    <div class="p-item selected" data-action="resume">Resume <span class="key">ESC / P</span></div>
    <div class="p-item" data-action="controls">Controls <span class="key">▶</span></div>
    <div class="p-item" data-action="quit">Quit to title <span class="key"></span></div>
    <div class="p-controls" id="pause-controls" style="display:none">
      WASD / Arrows &nbsp;<span>move</span><br>
      bump enemy &nbsp;<span>attack</span><br>
      walk over item &nbsp;<span>pick up</span><br>
      &gt; tile &nbsp;<span>descend floor</span><br>
      M &nbsp;<span>toggle minimap</span><br>
      L &nbsp;<span>toggle legend</span><br>
      F &nbsp;<span>toggle fullscreen</span><br>
      P / ESC &nbsp;<span>pause</span>
    </div>
  </div>
</div>

<!-- LEGEND PANEL -->
<div id="legend-wrap">
  <div id="legend-tab">ENEMIES [L]</div>
  <div id="legend-panel">
    <div id="legend-inner">
      <div class="l-title">FLOOR ENEMIES</div>
      <div id="legend-list"></div>
    </div>
  </div>
</div>
<div id="overlay">
  <canvas id="title-canvas" style="display:block;max-width:100%;"></canvas>
  <div class="sub">
    WASD / Arrows &nbsp;·&nbsp; bump enemies to attack &nbsp;·&nbsp; walk over items<br>
    attack has a cooldown &nbsp;·&nbsp; big enemies take more hits &nbsp;·&nbsp; <span style="color:#888">&gt;</span> to descend
  </div>
  <button class="btn" id="start-btn">[ ENTER THE DUNGEON ]</button>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════
//  CANVAS
// ═══════════════════════════════════════════════════════════════════════
const canvas = document.getElementById('c');
const ctx    = canvas.getContext('2d');
function resize() { canvas.width=window.innerWidth; canvas.height=window.innerHeight; }
resize();
window.addEventListener('resize',()=>{ resize(); drawTitleCanvas(); if(G.phase==='playing') draw(); });

// ═══════════════════════════════════════════════════════════════════════
//  CONSTANTS
// ═══════════════════════════════════════════════════════════════════════
const TS    = 22;
const MAP_W = 52;
const MAP_H = 52;
const TILE  = { WALL:0, FLOOR:1, STAIR:2 };

// ── Colours ──────────────────────────────────────────────────────────
const COL = {
  bg:          '#000',
  wallBg:      '#0a0a12',
  wallChDeep:  '#2a2a44',
  wallChMid:   '#2a2a44',
  wallChEdge:  '#2a2a44',
  wallEdgeLine:'#6060a0',
  floorBg:     '#060609',  floorDot:'#14141e',
  stairBg:     '#0d0d00',  stairChar:'#cccc00',
  player:      '#ffffff',
  fxSpeed:     '#55eeaa',  fxStr:'#ee6644',  fxRegen:'#44dd88',  fxSlow:'#88ccff',
};

// ═══════════════════════════════════════════════════════════════════════
//  ENEMY DEFINITIONS
// ═══════════════════════════════════════════════════════════════════════
const ENEMY_DEFS = {
  giant_rat:  { ch:'r', col:'#aa7733', hp:4,  dmg:1, armor:0, moveRate:14, attackRate:600,  counterChance:0.1, size:1, minFloor:1, pts:40,  name:'giant rat',      flavor:'Skitters in packs. Easy prey, but never alone.' },
  goblin:     { ch:'g', col:'#44bb44', hp:6,  dmg:1, armor:0, moveRate:22, attackRate:800,  counterChance:0.1, size:1, minFloor:1, pts:60,  name:'goblin',         flavor:'Weak alone, but fast. Tends to swarm.' },
  bat:        { ch:'b', col:'#886688', hp:3,  dmg:1, armor:0, moveRate:12, attackRate:500,  counterChance:0.2, size:1, minFloor:1, pts:35,  name:'bat',            flavor:'Erratic and frail. Hits before you notice it.' },
  skeleton:   { ch:'s', col:'#aaaaaa', hp:8,  dmg:2, armor:1, moveRate:20, attackRate:900,  counterChance:0.2, size:1, minFloor:1, pts:80,  name:'skeleton',       flavor:'Brittle bones deflect weak blows. Relentless.' },
  ghost:      { ch:'G', col:'#7777ee', hp:10, dmg:2, armor:0, moveRate:16, attackRate:700,  counterChance:0.3, size:1, minFloor:2, pts:100, name:'ghost',          flavor:'No armor, but swift and hard to pin down.' },
  zombie:     { ch:'z', col:'#556644', hp:14, dmg:2, armor:0, moveRate:40, attackRate:1200, counterChance:0.1, size:1, minFloor:2, pts:90,  name:'zombie',         flavor:'Slow and shambling, but it never truly dies.', selfRegen:0.8 },
  spider:     { ch:'S', col:'#cc8833', hp:7,  dmg:2, armor:0, moveRate:18, attackRate:700,  counterChance:0.4, size:1, minFloor:2, pts:85,  name:'spider',         flavor:'Fast legs, high counter chance. Watch your step.' },
  troll:      { ch:'T', col:'#ee5533', hp:28, dmg:3, armor:2, moveRate:38, attackRate:1200, counterChance:0.4, size:2, minFloor:2, pts:200, name:'troll',          flavor:'Thick hide. Slow but hits hard. Takes two tiles.' },
  archer:     { ch:'a', col:'#88bb55', hp:8,  dmg:3, armor:0, moveRate:24, attackRate:900,  counterChance:0.1, size:1, minFloor:2, pts:95,  name:'archer',         flavor:'Shoots on sight. Retreats when you close in.', ranged:{range:8,fleeDist:3} },
  wraith:     { ch:'W', col:'#aa55ff', hp:16, dmg:4, armor:1, moveRate:14, attackRate:600,  counterChance:0.5, size:1, minFloor:3, pts:200, name:'wraith',         flavor:'Fastest enemy. High counter chance. Fears nothing.' },
  mimic:      { ch:'?', col:'#cc9933', hp:14, dmg:4, armor:1, moveRate:20, attackRate:800,  counterChance:0.3, size:1, minFloor:3, pts:180, name:'mimic',          flavor:'Disguised as an item. Triggered when you walk near.', mimic:true },
  fire_elem:  { ch:'e', col:'#ff6622', hp:18, dmg:4, armor:0, moveRate:22, attackRate:750,  counterChance:0.35,size:1, minFloor:3, pts:170, name:'fire elemental', flavor:'No armor, but enrages at low HP. Keep your distance.', enrage:{hpPct:0.3,dmgBonus:3,moveRateBonus:-8} },
  vampire:    { ch:'V', col:'#cc2244', hp:22, dmg:4, armor:1, moveRate:20, attackRate:750,  counterChance:0.4, size:1, minFloor:4, pts:240, name:'vampire',        flavor:'Enrages below 30% HP — faster and deadlier.', enrage:{hpPct:0.3,dmgBonus:3,moveRateBonus:-10} },
  ogre:       { ch:'O', col:'#ff8844', hp:45, dmg:5, armor:3, moveRate:42, attackRate:1500, counterChance:0.3, size:2, minFloor:4, pts:300, name:'ogre',           flavor:'Massive. Heavy armor. Avoid unless well-armed.' },
  demon:      { ch:'&', col:'#ff3366', hp:30, dmg:5, armor:2, moveRate:20, attackRate:700,  counterChance:0.6, size:1, minFloor:5, pts:280, name:'demon',          flavor:'Cunning. Highest counter-attack rate of any foe.' },
  lich:       { ch:'L', col:'#aaddff', hp:35, dmg:5, armor:2, moveRate:24, attackRate:800,  counterChance:0.3, size:1, minFloor:5, pts:350, name:'lich',           flavor:'Summons skeletons when first struck. Do not let it stall.', summon:{type:'skeleton',count:2,onFirstHit:true} },
  dark_mage:  { ch:'m', col:'#8844cc', hp:20, dmg:6, armor:1, moveRate:26, attackRate:900,  counterChance:0.3, size:1, minFloor:5, pts:300, name:'dark mage',      flavor:'Summons a goblin each time you strike it.', summon:{type:'goblin',count:1,onFirstHit:false} },
  ice_golem:  { ch:'I', col:'#88ddff', hp:55, dmg:4, armor:5, moveRate:48, attackRate:1600, counterChance:0.2, size:2, minFloor:5, pts:380, name:'ice golem',      flavor:'Immense armor. Slows your movement on every hit.', slowPlayer:3000 },
  void_horror:{ ch:'v', col:'#cc44ff', hp:65, dmg:6, armor:3, moveRate:32, attackRate:1100, counterChance:0.4, size:2, minFloor:7, pts:500, name:'void horror',    flavor:'Splits into two void shards when slain.', onDeath:{type:'void_shard',count:2} },
  void_shard: { ch:'·', col:'#dd88ff', hp:12, dmg:3, armor:0, moveRate:16, attackRate:600,  counterChance:0.2, size:1, minFloor:99,pts:80,  name:'void shard',     flavor:'A fragment of the void horror. Still dangerous.' },
  dragon:     { ch:'@', col:'#ff2222', hp:80, dmg:7, armor:4, moveRate:30, attackRate:1000, counterChance:0.5, size:2, minFloor:6, pts:600, name:'dragon',         flavor:'Ancient. Enormous. Do not engage without potions.' },
};

// ═══════════════════════════════════════════════════════════════════════
//  WEAPON DEFINITIONS
// ═══════���═══════════════════════════════════════════════════════════════
const WEAPON_DEFS = {
  dagger:  { ch:')', col:'#cc9933', dmg:4,  attackMs:300, name:'dagger',  desc:'fast, light'  },
  sword:   { ch:'/', col:'#ccccee', dmg:7,  attackMs:500, name:'sword',   desc:'balanced'     },
  axe:     { ch:'\\',col:'#ee7733', dmg:12, attackMs:900, name:'axe',     desc:'slow, heavy'  },
  staff:   { ch:'|', col:'#aa66ff', dmg:9,  attackMs:700, name:'staff',   desc:'magic, medium'},
  bow:     { ch:'}', col:'#88cc44', dmg:6,  attackMs:400, name:'bow',     desc:'quick, ranged'},
  maul:    { ch:'!', col:'#ff8844', dmg:15, attackMs:1100,name:'maul',    desc:'very slow, huge dmg'},
};

// ═══════════════════════════════════════════════════════════════════════
//  POTION DEFINITIONS
// ═══════════════════════════════════════════════════════════════════════
const POTION_DEFS = {
  health:  { ch:'*', col:'#ee4466', name:'health potion',   effect:'heal',  value:8,  duration:0    },
  mana:    { ch:'*', col:'#4488ff', name:'mana potion',     effect:'regen', value:1,  duration:9000 },
  speed:   { ch:'*', col:'#44ffaa', name:'speed potion',    effect:'speed', value:0,  duration:6000 },
  strength:{ ch:'*', col:'#ff8833', name:'strength potion', effect:'str',   value:4,  duration:8000 },
};

// ═══════════════════════════════════════════════════════════════════════
//  GAME STATE
// ═══════════════════════════════════════════════════════════════════════
const G = {
  phase: 'title',
  floor: 1,
  map: null, rooms: [],
  wallOC: null,
  player: { x:2, y:2, hp:10, maxHp:10, baseDmg:3, baseAttackMs:500, weapon:null,
            atkCooldown:0 },
  enemies: [],
  items: [],
  effects: {},
  score:0, kills:0,
  regenTick:0,
  passRegenTick:0,
  attackFlash: [],
  dmgFlash: [],
  floatTexts: [],
  projectiles: [],
};

// ── Helpers ──────────────────────────────────────────────────────────
function playerDmg() {
  let d = G.player.weapon ? WEAPON_DEFS[G.player.weapon].dmg : G.player.baseDmg;
  if (G.effects.str) d += G.effects.str.val;
  return d;
}
function playerAtkMs() {
  let ms = G.player.weapon ? WEAPON_DEFS[G.player.weapon].attackMs : G.player.baseAttackMs;
  if (G.effects.speed) ms = Math.round(ms * 0.6);
  return ms;
}
function moveDt() {
  if(G.effects.speed) return 75;
  if(G.effects.slow)  return 260;
  return 140;
}

// ═══════════════════════════════════════════════════════════════════════
//  MAP GENERATION
// ═══════════════════════════════════════════════════════════════════════
function genMap(floor) {
  const map=[];
  for(let y=0;y<MAP_H;y++) map.push(new Array(MAP_W).fill(TILE.WALL));
  const rooms=[];
  for(let i=0;i<60+floor*4;i++){
    const rw=4+Math.floor(Math.random()*9), rh=4+Math.floor(Math.random()*9);
    const rx=1+Math.floor(Math.random()*(MAP_W-rw-2));
    const ry=1+Math.floor(Math.random()*(MAP_H-rh-2));
    let ok=true;
    for(const r of rooms) if(rx<r.x+r.w+1&&rx+rw>r.x-1&&ry<r.y+r.h+1&&ry+rh>r.y-1){ok=false;break;}
    if(!ok) continue;
    rooms.push({x:rx,y:ry,w:rw,h:rh});
    for(let cy=ry;cy<ry+rh;cy++) for(let cx=rx;cx<rx+rw;cx++) map[cy][cx]=TILE.FLOOR;
  }
  for(let i=1;i<rooms.length;i++){
    const a=rooms[i-1],b=rooms[i];
    const ax=Math.floor(a.x+a.w/2),ay=Math.floor(a.y+a.h/2);
    const bx=Math.floor(b.x+b.w/2),by=Math.floor(b.y+b.h/2);
    let cx=ax; while(cx!==bx){map[ay][cx]=TILE.FLOOR;cx+=(bx>ax)?1:-1;}
    let cy=ay; while(cy!==by){map[cy][bx]=TILE.FLOOR;cy+=(by>ay)?1:-1;}
    map[by][bx]=TILE.FLOOR;
  }
  if(rooms.length){
    const last=rooms[rooms.length-1];
    map[Math.floor(last.y+last.h/2)][Math.floor(last.x+last.w/2)]=TILE.STAIR;
  }
  const oc=[];
  for(let y=0;y<MAP_H;y++) oc.push(new Array(MAP_W).fill(0));
  for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
    if(map[y][x]!==TILE.WALL) continue;
    let c=0;
    for(const[dx,dy] of [[0,-1],[0,1],[-1,0],[1,0]]){
      const nx=x+dx,ny=y+dy;
      if(nx>=0&&ny>=0&&nx<MAP_W&&ny<MAP_H&&map[ny][nx]!==TILE.WALL) c++;
    }
    oc[y][x]=c;
  }
  return {map,rooms,oc};
}

function spawnEnemies(rooms,floor){
  const eligible=Object.entries(ENEMY_DEFS).filter(([k,d])=>d.minFloor<=floor && d.minFloor<99 && !d.mimic);
  const weighted=[];
  for(const entry of eligible){
    const floorDiff=floor-entry[1].minFloor;
    const w=Math.max(1,Math.min(5,floorDiff+1));
    for(let i=0;i<w;i++) weighted.push(entry);
  }
  const count=Math.min(5+floor*2,28);
  const pool=rooms.slice(1);
  const enemies=[];
  for(let i=0;i<count&&pool.length;i++){
    const r=pool[Math.floor(Math.random()*pool.length)];
    const [type,def]=weighted[Math.floor(Math.random()*weighted.length)];
    const ex=r.x+1+Math.floor(Math.random()*Math.max(1,r.w-2-(def.size-1)));
    const ey=r.y+1+Math.floor(Math.random()*Math.max(1,r.h-2-(def.size-1)));
    enemies.push(makeEnemy(type,ex,ey));
  }
  return enemies;
}

function spawnMimics(rooms,floor){
  if(floor<3) return [];
  const pool=rooms.slice(1);
  if(!pool.length) return [];
  const count=1+(floor>=5?1:0);
  const mimics=[];
  for(let i=0;i<count;i++){
    const r=pool[Math.floor(Math.random()*pool.length)];
    const mx=r.x+1+Math.floor(Math.random()*Math.max(1,r.w-2));
    const my=r.y+1+Math.floor(Math.random()*Math.max(1,r.h-2));
    mimics.push({x:mx,y:my,kind:'mimic',type:'mimic',id:Math.random()});
  }
  return mimics;
}

function makeEnemy(type,x,y){
  return {
    x,y,
    hp:ENEMY_DEFS[type].hp, maxHp:ENEMY_DEFS[type].hp,
    type,
    moveTick:0, atkCooldown:0,
    path:[], pathTick:0,
    id:Math.random(),
    enraged:false,
    summoned:false,
    regenTick:0,
  };
}

function spawnItems(rooms){
  const items=[];
  const pool=rooms.slice(1);
  if(!pool.length) return items;
  const wTypes=Object.keys(WEAPON_DEFS);
  const pTypes=Object.keys(POTION_DEFS);
  const nW=1+Math.floor(Math.random()*2);
  const nP=2+Math.floor(Math.random()*3);
  for(let i=0;i<nW;i++){
    const r=pool[Math.floor(Math.random()*pool.length)];
    items.push({x:r.x+1+Math.floor(Math.random()*Math.max(1,r.w-2)),
                y:r.y+1+Math.floor(Math.random()*Math.max(1,r.h-2)),
                kind:'weapon',type:wTypes[Math.floor(Math.random()*wTypes.length)],id:Math.random()});
  }
  for(let i=0;i<nP;i++){
    const r=pool[Math.floor(Math.random()*pool.length)];
    items.push({x:r.x+1+Math.floor(Math.random()*Math.max(1,r.w-2)),
                y:r.y+1+Math.floor(Math.random()*Math.max(1,r.h-2)),
                kind:'potion',type:pTypes[Math.floor(Math.random()*pTypes.length)],id:Math.random()});
  }
  return items;
}

function initFloor(num){
  const {map,rooms,oc}=genMap(num);
  G.floor=num; G.map=map; G.rooms=rooms; G.wallOC=oc;
  const s=rooms[0]||{x:2,y:2,w:4,h:4};
  G.player.x=Math.floor(s.x+s.w/2);
  G.player.y=Math.floor(s.y+s.h/2);
  G.enemies=spawnEnemies(rooms,num);
  G.items=[...spawnItems(rooms), ...spawnMimics(rooms,num)];
  G.effects={};
  G.regenTick=0; G.passRegenTick=0;
  G.player.atkCooldown=0;
  G.projectiles=[];
  camPX=G.player.x*TS; camPY=G.player.y*TS;
  camTX=camPX; camTY=camPY;
  msg(`Floor ${num}  —  ${G.enemies.length} enemies lurk ahead.`);
}

function startGame(){
  G.player.hp=G.player.maxHp;
  G.player.weapon=null;
  G.player.atkCooldown=0;
  G.kills=0; G.score=0;
  G.effects={}; G.floatTexts=[];
  G.phase='playing';
  MM.expanded=false;
  legendOpen=false;
  document.getElementById('legend-panel').classList.remove('open');
  document.getElementById('pause-overlay').classList.remove('active');
  document.getElementById('map-overlay').classList.remove('active');
  document.getElementById('minimap-toggle').textContent='MAP [M]';
  document.getElementById('overlay').style.display='none';
  initFloor(1);
  updateHUD();
  loop();
}

// ═══════════════════════════════════════════════════════════════════════
//  BFS PATHFINDING
// ════════════════════════════════════════════════���══════════════════════
function bfsStep(sx,sy,tx,ty,maxDist){
  if(sx===tx&&sy===ty) return null;
  const visited=new Map();
  const queue=[[sx,sy]];
  visited.set(`${sx},${sy}`,null);
  while(queue.length){
    const [cx,cy]=queue.shift();
    if(Math.abs(cx-sx)+Math.abs(cy-sy)>maxDist) continue;
    for(const[dx,dy] of [[0,-1],[0,1],[-1,0],[1,0]]){
      const nx=cx+dx,ny=cy+dy,key=`${nx},${ny}`;
      if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
      if(G.map[ny][nx]===TILE.WALL) continue;
      if(visited.has(key)) continue;
      visited.set(key,[cx,cy]);
      if(nx===tx&&ny===ty){
        let node=[nx,ny],prev=visited.get(key);
        while(prev&&(prev[0]!==sx||prev[1]!==sy)){node=prev;prev=visited.get(`${prev[0]},${prev[1]}`);}
        return node;
      }
      queue.push([nx,ny]);
    }
  }
  return null;
}

// ═══════════════════════════════════════════════════════════════════════
//  DEVICE DETECTION & FULLSCREEN
// ═══════════════════════════════════════════════════════════════════════
const DEVICE = {
  isTouchDevice: () => {
    return (('ontouchstart' in window) || 
            (navigator.maxTouchPoints > 0) || 
            (navigator.msMaxTouchPoints > 0));
  },
  isPhone: () => {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  },
  get type() {
    return this.isPhone() || this.isTouchDevice() ? 'mobile' : 'desktop';
  }
};

function requestFullscreen() {
  const elem = document.documentElement;
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
  } else if (elem.webkitRequestFullscreen) {
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) {
    elem.msRequestFullscreen();
  }
}

function exitFullscreen() {
  if (document.fullscreenElement) {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
  }
}

function toggleFullscreen() {
  if (!document.fullscreenElement && 
      !document.webkitFullscreenElement && 
      !document.msFullscreenElement) {
    requestFullscreen();
  } else {
    exitFullscreen();
  }
}

function updateFullscreenButton() {
  const btn = document.getElementById('fullscreen-btn');
  if (btn) {
    const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
    btn.classList.toggle('active', !!isFullscreen);
  }
}

// ═══════════════════════════════════════════════════════════════════════
//  INPUT
// ═══════════════════════════════════════════════════════════════════════
const keys={};
document.addEventListener('keydown',e=>{
  if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();

  if((e.key==='Escape'||e.key==='p'||e.key==='P') && (G.phase==='playing'||G.phase==='paused')){
    if(MM.expanded){ toggleMinimap(); return; }
    togglePause(); return;
  }
  if((e.key==='m'||e.key==='M') && (G.phase==='playing'||MM.expanded)){
    toggleMinimap(); return;
  }
  if((e.key==='l'||e.key==='L') && (G.phase==='playing' || legendOpen)){
    toggleLegend(); return;
  }
  if((e.key==='f'||e.key==='F')){
    toggleFullscreen(); return;
  }
  if(G.phase==='paused'){
    if(e.key==='ArrowUp'||e.key==='ArrowDown') pauseNav(e.key==='ArrowUp'?-1:1);
    if(e.key==='Enter') pauseSelect();
    return;
  }

  keys[e.key]=true;
});
document.addEventListener('keyup',e=>{ keys[e.key]=false; });

let moveDelay=0, lastTime=0;
let camPX=0,camPY=0,camTX=0,camTY=0;

function inputTick(dt){
  if(G.phase!=='playing') return;
  if(G.player.atkCooldown>0){
    G.player.atkCooldown=Math.max(0,G.player.atkCooldown-dt);
    updateHUDAtk();
  }
  moveDelay-=dt;
  if(moveDelay>0) return;
  let dx=0,dy=0;
  if     (keys['w']||keys['W']||keys['ArrowUp'])    dy=-1;
  else if(keys['s']||keys['S']||keys['ArrowDown'])  dy= 1;
  else if(keys['a']||keys['A']||keys['ArrowLeft'])  dx=-1;
  else if(keys['d']||keys['D']||keys['ArrowRight']) dx= 1;
  else return;
  moveDelay=moveDt();
  tryMove(dx,dy);
}

function enemyAt(nx,ny){
  return G.enemies.find(e=>{
    const def=ENEMY_DEFS[e.type];
    if(def.size===2) return (nx===e.x||nx===e.x+1)&&(ny===e.y||ny===e.y+1);
    return e.x===nx&&e.y===ny;
  });
}

function tryMove(dx,dy){
  const nx=G.player.x+dx, ny=G.player.y+dy;
  if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) return;
  if(G.map[ny][nx]===TILE.WALL) return;
  const enemy=enemyAt(nx,ny);
  if(enemy){ attackEnemy(enemy); return; }
  G.player.x=nx; G.player.y=ny;
  camTX=nx*TS; camTY=ny*TS;
  const item=G.items.find(i=>i.x===nx&&i.y===ny);
  if(item) pickupItem(item);
  if(G.map[ny][nx]===TILE.STAIR){ G.score+=200; updateHUD(); initFloor(G.floor+1); }
}

// ═══════════════════════════════════════════════════════════════════════
//  COMBAT
// ═══════════════════════════════════════════════════════════════════════
function attackEnemy(enemy){
  if(G.player.atkCooldown>0){
    msg(`Your attack isn't ready yet!`);
    return;
  }
  const def=ENEMY_DEFS[enemy.type];
  let dmg=playerDmg()+Math.floor(Math.random()*4);
  const blocked=Math.max(0,def.armor-Math.floor(Math.random()*2));
  dmg=Math.max(1,dmg-blocked);

  enemy.hp-=dmg;
  spawnFloat(enemy.x,enemy.y,`-${dmg}`,'#ffdd44');
  if(blocked>0) spawnFloat(enemy.x,enemy.y-1,`(${blocked} blocked)`,'#8888aa');

  G.player.atkCooldown=playerAtkMs();
  updateHUDAtk();

  G.attackFlash.push({x:enemy.x,y:enemy.y,t:300});

  if(enemy.hp<=0){
    killEnemy(enemy,def);
    return;
  }

  msg(`You hit the ${def.name} for ${dmg}${blocked>0?` (${blocked} blocked)`:''}. [${Math.max(0,enemy.hp)}/${enemy.maxHp} HP]`);

  if(def.enrage && !enemy.enraged && enemy.hp/enemy.maxHp <= def.enrage.hpPct){
    enemy.enraged=true;
    spawnFloat(enemy.x,enemy.y,'ENRAGED!',def.col);
    msg(`The ${def.name} ENRAGES — it becomes faster and hits harder!`);
  }

  if(def.summon){
    const alreadySummoned = def.summon.onFirstHit && enemy.summoned;
    if(!alreadySummoned){
      if(def.summon.onFirstHit) enemy.summoned=true;
      spawnMinions(enemy,def.summon.type,def.summon.count);
    }
  }

  if(Math.random()<def.counterChance && enemy.atkCooldown<=0){
    const cdmg=enemyAttackPlayer(enemy,def);
    if(cdmg>0) msg(`The ${def.name} counter-attacks for ${cdmg}!`);
  }
}

function killEnemy(enemy,def){
  G.enemies=G.enemies.filter(e=>e.id!==enemy.id);
  G.kills++;
  G.score+=def.pts;
  spawnFloat(enemy.x,enemy.y,'KILLED','#ff6644');
  msg(`The ${def.name} dies! (+${def.pts})`);
  updateHUD();
  if(def.onDeath){
    const {type,count}=def.onDeath;
    for(let i=0;i<count;i++){
      const ox=[0,1,0,-1][i]||0, oy=[0,0,1,0][i]||0;
      const sx=enemy.x+ox, sy=enemy.y+oy;
      if(G.map[sy]&&G.map[sy][sx]!==TILE.WALL){
        G.enemies.push(makeEnemy(type,sx,sy));
      } else {
        G.enemies.push(makeEnemy(type,enemy.x,enemy.y));
      }
    }
    msg(`The ${def.name} splits into ${count} void shards!`);
    updateHUD();
  }
}

function enemyAttackPlayer(enemy,def){
  const dmgBonus = (def.enrage && enemy.enraged) ? def.enrage.dmgBonus : 0;
  let dmg=(def.dmg+dmgBonus)+(Math.random()<0.3?1:0);
  dmg=Math.max(1,dmg);
  G.player.hp-=dmg;
  G.dmgFlash.push(0.45);
  spawnFloat(G.player.x,G.player.y,`-${dmg}`,'#ff4444');
  updateHUD();
  if(def.slowPlayer){
    G.effects.slow={t:def.slowPlayer};
    spawnFloat(G.player.x,G.player.y,'SLOWED','#88ccff');
    updateHUD();
  }
  if(G.player.hp<=0){ G.phase='dead'; showGameover(); }
  enemy.atkCooldown=def.attackRate;
  return dmg;
}
  
function spawnMinions(summoner,type,count){
  const def=ENEMY_DEFS[type];
  let spawned=0;
  const dirs=[[1,0],[-1,0],[0,1],[0,-1],[1,1],[-1,1],[1,-1],[-1,-1]];
  for(const[dx,dy] of dirs){
    if(spawned>=count) break;
    const nx=summoner.x+dx, ny=summoner.y+dy;
    if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
    if(G.map[ny][nx]===TILE.WALL) continue;
    if(G.enemies.some(e=>e.x===nx&&e.y===ny)) continue;
    G.enemies.push(makeEnemy(type,nx,ny));
    spawned++;
  }
  if(spawned>0) msg(`The ${ENEMY_DEFS[summoner.type].name} summons ${spawned} ${def.name}${spawned>1?'s':''}!`);
}

function spawnFloat(gx,gy,text,col){
  G.floatTexts.push({gx,gy,text,col,t:800,vy:-0.02});
}
  
function pickupItem(item){
  if(item.kind==='mimic'){
    G.items=G.items.filter(i=>i.id!==item.id);
    const e=makeEnemy('mimic',item.x,item.y);
    G.enemies.push(e);
    msg(`That wasn't an item — it's a MIMIC!`);
    G.dmgFlash.push(0.3);
    spawnFloat(item.x,item.y,'MIMIC!','#cc9933');
    return;
  }
  G.items=G.items.filter(i=>i.id!==item.id);
  if(item.kind==='weapon'){
    const def=WEAPON_DEFS[item.type];
    const old=G.player.weapon;
    G.player.weapon=item.type;
    const dropped=old?` (dropped ${WEAPON_DEFS[old].name})`:' ';
    msg(`Picked up ${def.name}! ${def.desc}${dropped}`);
    updateHUD();
  } else {
    applyPotion(POTION_DEFS[item.type]);
  }
}

function applyPotion(def){
  if(def.effect==='heal'){
    const gained=Math.min(def.value,G.player.maxHp-G.player.hp);
    G.player.hp=Math.min(G.player.maxHp,G.player.hp+def.value);
    spawnFloat(G.player.x,G.player.y,`+${gained} HP`,'#44ee88');
    msg(`You drink the ${def.name}. +${gained} HP`);
    updateHUD();
  } else if(def.effect==='regen'){
    G.effects.regen={t:def.duration,val:def.value};
    msg(`You drink the ${def.name}. HP will regenerate.`);
  } else if(def.effect==='speed'){
    G.effects.speed={t:def.duration};
    msg(`You drink the ${def.name}. You move faster and attack quicker!`);
  } else if(def.effect==='str'){
    G.effects.str={t:def.duration,val:def.value};
    msg(`You drink the ${def.name}. Your attacks hit harder!`);
  }
  updateHUD();
}

// ═══════════════════════════════════════════════════════════════════════
//  ENEMY TICK
// ═══════════════════════════════════════════════════════════════════════
function enemyTick(dt){
  if(G.phase!=='playing') return;

  for(const key of Object.keys(G.effects)){
    G.effects[key].t-=dt;
    if(G.effects[key].t<=0){ delete G.effects[key]; msg(`${key} wears off.`); updateHUD(); }
  }

  if(G.effects.regen){
    G.regenTick+=dt;
    if(G.regenTick>1200){ G.regenTick=0; healPlayer(G.effects.regen.val); }
  }

  G.passRegenTick+=dt;
  if(G.passRegenTick>8000){ G.passRegenTick=0; healPlayer(1); }

  G.projectiles=G.projectiles.filter(p=>p.t>0);
  for(const p of G.projectiles){
    p.t-=dt;
    p.px+=p.vx*(dt/120);
    p.py+=p.vy*(dt/120);
    const tx=Math.round(p.px), ty=Math.round(p.py);
    if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H||G.map[ty][tx]===TILE.WALL){ p.t=0; continue; }
    if(tx===G.player.x&&ty===G.player.y){
      G.player.hp-=p.dmg; G.dmgFlash.push(0.35);
      spawnFloat(G.player.x,G.player.y,`-${p.dmg}`,'#ffaa44');
      msg(`An arrow hits you for ${p.dmg}!`);
      updateHUD();
      if(G.player.hp<=0){ G.phase='dead'; showGameover(); }
      p.t=0;
    }
  }

  const px=G.player.x, py=G.player.y;

  for(const e of G.enemies){
    const def=ENEMY_DEFS[e.type];
    e.moveTick+=dt;
    if(e.atkCooldown>0) e.atkCooldown=Math.max(0,e.atkCooldown-dt);

    if(def.selfRegen){
      e.regenTick=(e.regenTick||0)+dt;
      if(e.regenTick>3000){ e.regenTick=0; e.hp=Math.min(e.maxHp,e.hp+Math.ceil(def.selfRegen)); }
    }

    const dist=Math.abs(px-e.x)+Math.abs(py-e.y);

    if(def.ranged){
      const {range,fleeDist}=def.ranged;
      if(dist<=fleeDist){
        if(e.moveTick>=def.moveRate*(1000/60)){
          e.moveTick=0;
          const best=fleeStep(e.x,e.y,px,py);
          if(best&&!enemyOccupies(best[0],best[1],e)) { e.x=best[0]; e.y=best[1]; }
        }
        continue;
      }
      if(dist<=range && e.atkCooldown<=0 && hasLOS(e.x,e.y,px,py)){
        const dmg=def.dmg+(Math.random()<0.25?1:0);
        const dx2=px-e.x, dy2=py-e.y;
        const len=Math.sqrt(dx2*dx2+dy2*dy2)||1;
        G.projectiles.push({px:e.x,py:e.y,vx:dx2/len,vy:dy2/len,dmg,t:1200,id:Math.random()});
        e.atkCooldown=def.attackRate;
        msg(`The archer fires an arrow!`);
        continue;
      }
      if(dist>range && e.moveTick>=def.moveRate*(1000/60)){
        e.moveTick=0;
        const step=bfsStep(e.x,e.y,px,py,22);
        if(step&&!enemyOccupies(step[0],step[1],e)) { e.x=step[0]; e.y=step[1]; }
      }
      continue;
    }

    const adjacent=isEnemyAdjacentToPlayer(e,def);

    if(adjacent && e.atkCooldown<=0){
      const dmg=enemyAttackPlayer(e,def);
      msg(`The ${def.name} strikes you for ${dmg}!`);
      continue;
    }

    const enragedRate = (def.enrage&&e.enraged)
      ? def.moveRate + def.enrage.moveRateBonus
      : def.moveRate;
    const rate=enragedRate*(1000/60);

    if(e.moveTick<rate) continue;
    e.moveTick=0;

    if(dist>16) continue;

    e.pathTick=(e.pathTick||0)+1;
    if(!e.path||e.path.length===0||e.pathTick%4===0){
      const step=bfsStep(e.x,e.y,px,py,24);
      e.path=step?[step]:[];
    }

    if(e.path&&e.path.length>0){
      const[nx,ny]=e.path.shift();
      if(!enemyOccupies(nx,ny,e)&&!(nx===px&&ny===py)){
        e.x=nx; e.y=ny;
      } else {
        e.path=[];
      }
    }
  }
}

function enemyOccupies(nx,ny,self){
  return G.enemies.some(o=>{
    if(o===self) return false;
    const od=ENEMY_DEFS[o.type];
    if(od.size===2) return (nx===o.x||nx===o.x+1)&&(ny===o.y||ny===o.y+1);
    return o.x===nx&&o.y===ny;
  });
}

function fleeStep(ex,ey,px,py){
  const dirs=[[0,-1],[0,1],[-1,0],[1,0]];
  let best=null, bestDist=-1;
  for(const[dx,dy] of dirs){
    const nx=ex+dx,ny=ey+dy;
    if(nx<0||ny<0||nx>=MAP_W||ny>=MAP_H) continue;
    if(G.map[ny][nx]===TILE.WALL) continue;
    const d=Math.abs(nx-px)+Math.abs(ny-py);
    if(d>bestDist){ bestDist=d; best=[nx,ny]; }
  }
  return best;
}

function hasLOS(x0,y0,x1,y1){
  let dx=Math.abs(x1-x0),dy=Math.abs(y1-y0);
  let sx=x0<x1?1:-1, sy=y0<y1?1:-1;
  let err=dx-dy;
  let cx=x0,cy=y0;
  while(true){
    if(cx===x1&&cy===y1) return true;
    if(G.map[cy][cx]===TILE.WALL) return false;
    const e2=2*err;
    if(e2>-dy){err-=dy;cx+=sx;}
    if(e2< dx){err+=dx;cy+=sy;}
  }
}

function healPlayer(amount){
  if(G.player.hp>=G.player.maxHp) return;
  G.player.hp=Math.min(G.player.maxHp,G.player.hp+amount);
  updateHUD();
}

function isEnemyAdjacentToPlayer(e,def){
  const px=G.player.x,py=G.player.y;
  const tiles=def.size===2
    ?[[e.x,e.y],[e.x+1,e.y],[e.x,e.y+1],[e.x+1,e.y+1]]
    :[[e.x,e.y]];
  for(const[ex,ey] of tiles){
    if(Math.abs(px-ex)<=1&&Math.abs(py-ey)<=1) return true;
  }
  return false;
}

// ═══════════════════════════════════════════════════════════════════════
//  DRAW
// ═══════════════════════════════════════════════════════════════════════
function cellHash(x,y){
  let h=(x*73856093)^(y*19349663);
  h=((h>>>16)^h)*0x45d9f3b;
  return Math.abs(h)%100;
}
function tileToScreen(gx,gy){
  return{
    sx:Math.round(gx*TS-camPX+canvas.width/2),
    sy:Math.round(gy*TS-camPY+canvas.height/2-14),
  };
}
function visibleRange(){
  const cols=Math.ceil(canvas.width/TS)+3, rows=Math.ceil(canvas.height/TS)+3;
  const cx=Math.round(camPX/TS), cy=Math.round(camPY/TS);
  return{x0:cx-Math.ceil(cols/2),x1:cx+Math.ceil(cols/2),y0:cy-Math.ceil(rows/2),y1:cy+Math.ceil(rows/2)};
}
function isOpen(x,y){ if(x<0||y<0||x>=MAP_W||y>=MAP_H) return false; return G.map[y][x]!==TILE.WALL; }

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle=COL.bg; ctx.fillRect(0,0,canvas.width,canvas.height);
  if(G.phase==='title'||!G.map) return;

  camPX+=(camTX-camPX)*0.18;
  camPY+=(camTY-camPY)*0.18;

  ctx.font=`${TS}px 'Courier New'`;
  ctx.textAlign='center'; ctx.textBaseline='middle';

  const{x0,x1,y0,y1}=visibleRange();

  for(let gy=Math.max(0,y0);gy<=Math.min(MAP_H-1,y1);gy++){
    for(let gx=Math.max(0,x0);gx<=Math.min(MAP_W-1,x1);gx++){
      const t=G.map[gy][gx];
      const{sx,sy}=tileToScreen(gx,gy);
      if(t===TILE.WALL){
        ctx.fillStyle=COL.wallBg;
      } else if(t===TILE.STAIR){
        ctx.fillStyle=COL.stairBg;
      } else {
        ctx.fillStyle=COL.floorBg;
      }
      ctx.fillRect(sx,sy,TS,TS);
    }
  }

  for(let gy=Math.max(0,y0);gy<=Math.min(MAP_H-1,y1);gy++){
    for(let gx=Math.max(0,x0);gx<=Math.min(MAP_W-1,x1);gx++){
      const t=G.map[gy][gx];
      const{sx,sy}=tileToScreen(gx,gy);
      const h=cellHash(gx,gy);
      const ccx=sx+TS/2,ccy=sy+TS/2;

      if(t===TILE.WALL){
        const oc=G.wallOC[gy][gx];
        ctx.fillStyle=COL.wallChDeep;
        if(oc===0){
          const wc = h<8?'·': h<16?',': h<28?'·': null;
          if(wc) ctx.fillText(wc,ccx,ccy);
        } else if(oc===1){
          ctx.fillText(h<35?'░': h<65?'#': h<80?'▒': '░', ccx,ccy);
        } else {
          ctx.fillText(h<60?'▓':'▒', ccx,ccy);
        }
        ctx.strokeStyle=COL.wallEdgeLine; ctx.lineWidth=1.5;
        const off=0.75;
        if(isOpen(gx,gy-1)){ctx.beginPath();ctx.moveTo(sx,sy+off);ctx.lineTo(sx+TS,sy+off);ctx.stroke();}
        if(isOpen(gx,gy+1)){ctx.beginPath();ctx.moveTo(sx,sy+TS-off);ctx.lineTo(sx+TS,sy+TS-off);ctx.stroke();}
        if(isOpen(gx-1,gy)){ctx.beginPath();ctx.moveTo(sx+off,sy);ctx.lineTo(sx+off,sy+TS);ctx.stroke();}
        if(isOpen(gx+1,gy)){ctx.beginPath();ctx.moveTo(sx+TS-off,sy);ctx.lineTo(sx+TS-off,sy+TS);ctx.stroke();}
      } else if(t===TILE.FLOOR){
        if(h<20){ctx.fillStyle=COL.floorDot;ctx.fillText('·',ccx,ccy);}
      } else if(t===TILE.STAIR){
        ctx.fillStyle=COL.stairChar;
        ctx.font=`bold ${TS}px 'Courier New'`;
        ctx.fillText('>',ccx,ccy);
        ctx.font=`${TS}px 'Courier New'`;
      }
    }
  }

  for(const item of G.items){
    const{sx,sy}=tileToScreen(item.x,item.y);
    if(sx<-TS||sy<-TS||sx>canvas.width+TS||sy>canvas.height+TS) continue;
    if(item.kind==='mimic'){
      ctx.fillStyle='#cc9933';
      ctx.fillText('?',sx+TS/2,sy+TS/2);
    } else {
      const def=item.kind==='weapon'?WEAPON_DEFS[item.type]:POTION_DEFS[item.type];
      ctx.fillStyle=def.col;
      ctx.fillText(def.ch,sx+TS/2,sy+TS/2);
    }
  }

  for(const p of G.projectiles){
    if(p.t<=0) continue;
    const{sx,sy}=tileToScreen(Math.round(p.px),Math.round(p.py));
    if(sx<-TS||sy<-TS||sx>canvas.width+TS||sy>canvas.height+TS) continue;
    ctx.fillStyle=`rgba(255,200,80,${Math.min(1,p.t/400)})`;
    ctx.font=`${TS}px 'Courier New'`;
    const ch = Math.abs(p.vx)>Math.abs(p.vy) ? (p.vx>0?'→':'←') : (p.vy>0?'↓':'↑');
    ctx.fillText(ch,sx+TS/2,sy+TS/2);
  }

  for(const e of G.enemies){
    const{sx,sy}=tileToScreen(e.x,e.y);
    if(sx<-TS*3||sy<-TS*3||sx>canvas.width+TS*3||sy>canvas.height+TS*3) continue;
    const def=ENEMY_DEFS[e.type];
    const isLarge=def.size===2;
    const w=isLarge?TS*2-2:TS-2;

    ctx.fillStyle='#1a0000'; ctx.fillRect(sx+1,sy,w,2);
    ctx.fillStyle='#880000'; ctx.fillRect(sx+1,sy,w*(e.hp/e.maxHp),2);
    if(def.armor>0){
      const maxArmor=def.armor*2;
      ctx.fillStyle='#00001a'; ctx.fillRect(sx+1,sy+3,w,2);
      ctx.fillStyle='#334488'; ctx.fillRect(sx+1,sy+3,w*(def.armor/maxArmor),2);
    }

    ctx.fillStyle=def.col;
    if(isLarge){
      ctx.font=`bold ${TS*2-2}px 'Courier New'`;
      ctx.fillText(def.ch, sx+TS, sy+TS+3);
      ctx.font=`${TS}px 'Courier New'`;
    } else {
      ctx.fillText(def.ch, sx+TS/2, sy+TS/2);
    }
  }

  {
    const{sx,sy}=tileToScreen(G.player.x,G.player.y);
    if(G.effects.speed){ ctx.fillStyle='rgba(80,255,180,0.07)'; ctx.fillRect(sx,sy,TS,TS); }
    if(G.effects.str){ ctx.fillStyle='rgba(255,120,60,0.07)'; ctx.fillRect(sx,sy,TS,TS); }
    const atkReady=G.player.atkCooldown<=0;
    ctx.fillStyle=atkReady?COL.player:'#888888';
    ctx.font=`${TS}px 'Courier New'`;
    ctx.fillText('@',sx+TS/2,sy+TS/2);
  }

  G.attackFlash=G.attackFlash.filter(f=>f.t>0);
  for(const f of G.attackFlash){
    const{sx,sy}=tileToScreen(f.x,f.y);
    ctx.fillStyle=`rgba(255,255,60,${f.t/300})`;
    ctx.font=`${TS}px 'Courier New'`;
    ctx.fillText('*',sx+TS/2,sy+TS/2);
    f.t-=16;
  }

  G.floatTexts=G.floatTexts.filter(f=>f.t>0);
  for(const f of G.floatTexts){
    const{sx,sy}=tileToScreen(f.gx,f.gy);
    const progress=1-(f.t/800);
    const alpha=f.t<300?f.t/300:1;
    const fy=sy+TS/2-progress*24;
    ctx.globalAlpha=alpha;
    ctx.font=`bold 11px 'Courier New'`;
    ctx.textAlign='center';
    ctx.fillStyle=f.col;
    ctx.fillText(f.text,sx+TS/2,fy);
    ctx.globalAlpha=1;
    f.t-=16; f.gy+=f.vy;
  }
  ctx.font=`${TS}px 'Courier New'`;
  ctx.textAlign='center'; ctx.textBaseline='middle';

  if(G.dmgFlash.length){
    const a=Math.max(...G.dmgFlash);
    const grd=ctx.createRadialGradient(canvas.width/2,canvas.height/2,canvas.height*0.1,canvas.width/2,canvas.height/2,canvas.height*0.7);
    grd.addColorStop(0,'rgba(160,0,0,0)'); grd.addColorStop(1,`rgba(180,0,0,${a})`);
    ctx.fillStyle=grd; ctx.fillRect(0,0,canvas.width,canvas.height);
    G.dmgFlash=G.dmgFlash.map(v=>v-0.022).filter(v=>v>0);
  }

  const fg=ctx.createRadialGradient(canvas.width/2,canvas.height/2,canvas.height*0.22,canvas.width/2,canvas.height/2,canvas.height*0.72);
  fg.addColorStop(0,'rgba(0,0,0,0)'); fg.addColorStop(1,'rgba(0,0,0,0.88)');
  ctx.fillStyle=fg; ctx.fillRect(0,0,canvas.width,canvas.height);
}

// ═══════════════════════════════════════════════════════════════════════
//  HUD
// ═══════════════════════════════════════════════════════════════════════
function updateHUDAtk(){
  const pct=G.player.atkCooldown<=0?100:Math.round((1-G.player.atkCooldown/playerAtkMs())*100);
  document.getElementById('h-atk').style.width=pct+'%';
  document.getElementById('h-atk').style.background=pct>=100?'#44aa66':'#557';
}

function updateHUD(){
  document.getElementById('h-floor').textContent=`Floor ${G.floor}`;
  document.getElementById('h-kills').textContent=G.kills;
  document.getElementById('h-score').textContent=G.score;
  document.getElementById('h-hpnum').textContent=`${Math.max(0,G.player.hp)}/${G.player.maxHp}`;
  document.getElementById('h-hp').style.width=Math.max(0,G.player.hp/G.player.maxHp*100)+'%';
  const wpn=G.player.weapon;
  document.getElementById('h-wpn').textContent=wpn?`${WEAPON_DEFS[wpn].name} (${WEAPON_DEFS[wpn].dmg}dmg)`:'fists';
  updateHUDAtk();
  const bar=document.getElementById('fx-bar');
  bar.innerHTML='';
  for(const[key,val] of Object.entries(G.effects)){
    const s=Math.ceil(val.t/1000);
    const pill=document.createElement('span'); pill.className='fx-pill';
    const cols={speed:COL.fxSpeed,str:COL.fxStr,regen:COL.fxRegen,slow:COL.fxSlow};
    pill.style.color=cols[key]||'#888'; pill.style.borderColor=cols[key]||'#333';
    pill.textContent=`${key} ${s}s`; bar.appendChild(pill);
  }
}

let msgTO;
function msg(text){
  const el=document.getElementById('msg-text');
  el.innerHTML=`<span class="hi">${text}</span>`;
  clearTimeout(msgTO);
  msgTO=setTimeout(()=>{ el.innerHTML=''; },3500);
}

// ═══════════════════════════════════════════════════════════════════════
//  GAME OVER
// ═══════════════════════════════════════════════════════════════════════
function showGameover(){
  const ov=document.getElementById('overlay'); ov.style.display='flex';
  ov.innerHTML=`<pre style="color:#555;text-align:center;line-height:2.2">
you died.

  score  <span style="color:#bbb">${G.score}</span>
  kills  <span style="color:#bbb">${G.kills}</span>
  floor  <span style="color:#bbb">${G.floor}</span>
  weapon <span style="color:#bbb">${G.player.weapon?WEAPON_DEFS[G.player.weapon].name:'fists'}</span>
</pre>
<button class="btn" onclick="location.reload()">[ try again ]</button>`;
}

// ═══════════════════════════════════════════════════════════════════════
//  LOOP
// ═══════════════════════════════════════════════════════════════════════
function loop(ts=0){
  if(G.phase==='dead'){ draw(); return; }
  const dt=(G.phase==='paused')?0:(ts-lastTime);
  lastTime=ts;
  if(G.phase==='playing'){ inputTick(dt); enemyTick(dt); }
  draw();
  drawMinimap();
  requestAnimationFrame(loop);
}

document.getElementById('start-btn').addEventListener('click',startGame);
document.addEventListener('keydown',e=>{ if(e.key==='Enter'&&G.phase==='title') startGame(); });
draw();

// ═══════════════════════════════════════════════════════════════════════
//  MINIMAP
// ═══════════════════════════════════════��═══════════════════════════════
const MM = { expanded: false, SIZE_SMALL: 120 };

function renderMapToCanvas(mc, fullscreen){
  if(!mc||!G.map) return;
  const mctx = mc.getContext('2d');
  const W = mc.width, H = mc.height;
  mctx.fillStyle='#000'; mctx.fillRect(0,0,W,H);
  const cellW = W/MAP_W, cellH = H/MAP_H;

  for(let y=0;y<MAP_H;y++) for(let x=0;x<MAP_W;x++){
    const t=G.map[y][x];
    if(t===TILE.WALL) continue;
    mctx.fillStyle = t===TILE.STAIR ? '#888800' : '#1e1e2e';
    mctx.fillRect(x*cellW, y*cellH, Math.ceil(cellW), Math.ceil(cellH));
  }
  for(const item of G.items){
    const def=item.kind==='weapon'?WEAPON_DEFS[item.type]:POTION_DEFS[item.type];
    mctx.fillStyle=def.col;
    const s=Math.max(2,cellW*0.6);
    mctx.fillRect(item.x*cellW+(cellW-s)/2, item.y*cellH+(cellH-s)/2, s, s);
  }
  for(const e of G.enemies){
    mctx.fillStyle=ENEMY_DEFS[e.type].col;
    const esz=ENEMY_DEFS[e.type].size;
    mctx.fillRect(e.x*cellW, e.y*cellH, Math.ceil(cellW*esz), Math.ceil(cellH*esz));
  }
  mctx.fillStyle='#fff';
  mctx.fillRect(G.player.x*cellW-1, G.player.y*cellH-1, cellW+2, cellH+2);

  mctx.strokeStyle='#333'; mctx.lineWidth=1;
  mctx.strokeRect(0.5,0.5,W-1,H-1);

  if(fullscreen){
    mctx.fillStyle='rgba(0,0,0,0.75)'; mctx.fillRect(0,0,W,22);
    mctx.fillStyle='#666'; mctx.font=`12px 'Courier New'`;
    mctx.textAlign='left'; mctx.textBaseline='middle';
    mctx.fillText(`Floor ${G.floor}   @(${G.player.x}, ${G.player.y})`, 10, 11);
    mctx.textAlign='right';
    mctx.fillText(`${G.enemies.length} enemies remaining`, W-10, 11);
    const types=[...new Set(G.enemies.map(e=>e.type))];
    mctx.font=`11px 'Courier New'`; mctx.textAlign='left';
    types.forEach((type,i)=>{
      const def=ENEMY_DEFS[type], count=G.enemies.filter(e=>e.type===type).length;
      const iy=H-10-i*16;
      mctx.fillStyle='rgba(0,0,0,0.6)'; mctx.fillRect(6,iy-8,130,14);
      mctx.fillStyle=def.col; mctx.fillRect(8,iy-4,8,8);
      mctx.fillStyle='#777'; mctx.fillText(`${def.name} ×${count}`,22,iy);
    });
    mctx.fillStyle='#888800'; mctx.fillRect(W-80,H-18,8,8);
    mctx.fillStyle='#555'; mctx.textAlign='left';
    mctx.fillText('stairs',W-68,H-14);
  }
}

function drawMinimap(){
  const mc=document.getElementById('minimap-canvas');
  if(!mc||!G.map) return;
  mc.width=MM.SIZE_SMALL; mc.height=MM.SIZE_SMALL;
  renderMapToCanvas(mc, false);
}

function drawMinimapFullscreen(){
  const mc=document.getElementById('map-overlay-canvas');
  if(!mc||!G.map) return;
  const sz=Math.min(Math.floor(window.innerWidth*0.9), Math.floor(window.innerHeight*0.85));
  mc.width=sz; mc.height=sz;
  renderMapToCanvas(mc, true);
}

function toggleMinimap(){
  MM.expanded=!MM.expanded;
  const overlay=document.getElementById('map-overlay');
  if(MM.expanded){
    G.phase='paused';
    overlay.classList.add('active');
    document.getElementById('minimap-toggle').textContent='MAP [M] ▾';
    drawMinimapFullscreen();
  } else {
    overlay.classList.remove('active');
    document.getElementById('minimap-toggle').textContent='MAP [M]';
    G.phase='playing';
    lastTime=performance.now();
  }
}

document.getElementById('minimap-toggle').addEventListener('click',()=>{
  if(G.phase==='playing') toggleMinimap();
  else if(MM.expanded) toggleMinimap();
});
document.getElementById('minimap-canvas').addEventListener('click',()=>{
  if(G.phase==='playing') toggleMinimap();
});
document.getElementById('map-overlay').addEventListener('click',()=>{
  if(MM.expanded) toggleMinimap();
});

// ═══════════════════════════════════════════════════════════════════════
//  PAUSE MENU
// ═══════════════════════════════════════════════════════════════════════
let pauseSelectedIndex = 0;
const PAUSE_ITEMS = ['resume','controls','quit'];

function togglePause(){
  if(MM.expanded) return;
  if(G.phase==='playing'){
    G.phase='paused';
    document.getElementById('pause-overlay').classList.add('active');
    pauseSelectedIndex=0;
    renderPauseSelection();
  } else if(G.phase==='paused'){
    G.phase='playing';
    document.getElementById('pause-overlay').classList.remove('active');
    document.getElementById('pause-controls').style.display='none';
    lastTime=performance.now();
  }
}

function renderPauseSelection(){
  document.querySelectorAll('.p-item').forEach((el,i)=>{
    el.classList.toggle('selected', i===pauseSelectedIndex);
  });
}

function pauseNav(dir){
  pauseSelectedIndex=(pauseSelectedIndex+dir+PAUSE_ITEMS.length)%PAUSE_ITEMS.length;
  renderPauseSelection();
}

function pauseSelect(){
  const action=PAUSE_ITEMS[pauseSelectedIndex];
  if(action==='resume'){
    togglePause();
  } else if(action==='controls'){
    const ctrl=document.getElementById('pause-controls');
    ctrl.style.display = ctrl.style.display==='none' ? 'block' : 'none';
  } else if(action==='quit'){
    location.reload();
  }
}

document.querySelectorAll('.p-item').forEach((el,i)=>{
  el.addEventListener('click',()=>{
    pauseSelectedIndex=i;
    renderPauseSelection();
    pauseSelect();
  });
});

// ═══════════════════════════════════════════════════════════════════════
//  LEGEND PANEL
// ═══════════════════════════════════════════════════════════════════════
let legendOpen = false;

function toggleLegend(){
  legendOpen = !legendOpen;
  document.getElementById('legend-panel').classList.toggle('open', legendOpen);
  if(legendOpen){
    buildLegend();
    if(G.phase==='playing'){ G.phase='paused'; lastTime=performance.now(); }
  } else {
    if(G.phase==='paused' && !MM.expanded){
      G.phase='playing'; lastTime=performance.now();
    }
  }
}

document.getElementById('legend-tab').addEventListener('click',()=>{
  if(G.phase==='playing'||G.phase==='paused') toggleLegend();
});

function buildLegend(){
  const types=[...new Set(G.enemies.map(e=>e.type))];
  types.sort((a,b)=>ENEMY_DEFS[a].minFloor-ENEMY_DEFS[b].minFloor);
  const mimicPresent=G.items.some(i=>i.kind==='mimic');
  if(mimicPresent && !types.includes('mimic')) types.unshift('mimic');

  const list=document.getElementById('legend-list');
  if(!types.length){
    list.innerHTML='<div style="color:#333;font-size:11px">Floor cleared!</div>';
    return;
  }
  list.innerHTML=types.map(type=>{
    const d=ENEMY_DEFS[type];
    const enemyCount=G.enemies.filter(e=>e.type===type).length;
    const itemCount=type==='mimic'?G.items.filter(i=>i.kind==='mimic').length:0;
    const count=enemyCount+itemCount;
    const sizeLabel=d.size===2?' <span style="color:#444">2×2</span>':'';
    const tags=[];
    if(d.enrage)     tags.push(`<span style="color:#ff6622">enrages</span>`);
    if(d.summon)     tags.push(`<span style="color:#aaddff">summoner</span>`);
    if(d.ranged)     tags.push(`<span style="color:#88bb55">ranged</span>`);
    if(d.selfRegen)  tags.push(`<span style="color:#44dd88">regen</span>`);
    if(d.onDeath)    tags.push(`<span style="color:#cc44ff">splits</span>`);
    if(d.slowPlayer) tags.push(`<span style="color:#88ccff">slows</span>`);
    if(d.mimic)      tags.push(`<span style="color:#cc9933">mimic</span>`);
    const tagStr=tags.length?`<br>${tags.join(' ')}`:'';
    return `<div class="l-entry">
      <div class="l-head">
        <span class="l-ch" style="color:${d.col}">${d.ch}</span>
        <span class="l-name">${d.name}${sizeLabel}</span>
        <span style="color:#333;font-size:10px;margin-left:auto">×${count}</span>
      </div>
      <div class="l-stats">
        HP <span>${d.hp}</span> &nbsp; DMG <span>${d.dmg}</span> &nbsp; ARM <span>${d.armor}</span> &nbsp; PTS <span>${d.pts}</span><br>
        CTR <span>${Math.round(d.counterChance*100)}%</span> &nbsp; SPD <span>${d.moveRate<18?'fast':d.moveRate<28?'medium':d.moveRate<38?'slow':'very slow'}</span>${tagStr}
      </div>
      <div class="l-flavor">${d.flavor}</div>
    </div>`;
  }).join('');
}

const FONT5={
  D:[[1,1,1,0,0],[1,0,0,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,1,0],[1,1,1,0,0]],
  U:[[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
  N:[[1,0,0,0,1],[1,1,0,0,1],[1,0,1,0,1],[1,0,0,1,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1]],
  G:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,0],[1,0,1,1,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
  E:[[1,1,1,1,1],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,0],[1,0,0,0,0],[1,0,0,0,0],[1,1,1,1,1]],
  O:[[0,1,1,1,0],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[1,0,0,0,1],[0,1,1,1,0]],
};
const WORD=['D','U','N','G','E','O','N'];

function drawTitleCanvas(){
  const tc=document.getElementById('title-canvas');
  if(!tc) return;
  const ROWS=7, COLS=WORD.length*5+(WORD.length-1);
  const T=Math.min(Math.floor(window.innerWidth*0.72/COLS),Math.floor(window.innerHeight*0.28/ROWS),34);
  if(T<4) return;
  tc.width=COLS*T; tc.height=(ROWS+2.5)*T;
  const tc2=tc.getContext('2d');
  tc2.clearRect(0,0,tc.width,tc.height);
  tc2.font=`${T}px 'Courier New'`; tc2.textAlign='center'; tc2.textBaseline='middle';

  const grid=[];
  for(let r=0;r<ROWS;r++) grid.push(new Array(COLS).fill(0));
  WORD.forEach((letter,li)=>{
    const bmp=FONT5[letter],offX=li*6;
    for(let r=0;r<ROWS;r++) for(let c=0;c<5;c++) if(bmp[r][c]) grid[r][offX+c]=1;
  });

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const sx=c*T,sy=r*T;
      if(!grid[r][c]){
        tc2.fillStyle='#040407'; tc2.fillRect(sx,sy,T,T);
        const hf=((c*31+r*53)*11)%100;
        if(hf<15){tc2.fillStyle='#0c0c14';tc2.fillText('·',sx+T/2,sy+T/2);}
        continue;
      }
      let oc=0;
      if(r>0&&!grid[r-1][c]) oc++;
      if(r<ROWS-1&&!grid[r+1][c]) oc++;
      if(c>0&&!grid[r][c-1]) oc++;
      if(c<COLS-1&&!grid[r][c+1]) oc++;
      const h=((c*7+r*13)*17)%100;
      const wallCol='#2a2a44';
      if(oc===0){
        tc2.fillStyle='#0a0a12'; tc2.fillRect(sx,sy,T,T);
        tc2.fillStyle=wallCol;
        const wc=h<8?'·':h<16?',':h<28?'·':null;
        if(wc) tc2.fillText(wc,sx+T/2,sy+T/2);
      } else if(oc===1){
        tc2.fillStyle='#0a0a12'; tc2.fillRect(sx,sy,T,T);
        tc2.fillStyle=wallCol;
        tc2.fillText(h<35?'░':h<65?'#':h<80?'▒':'░',sx+T/2,sy+T/2);
      } else {
        tc2.fillStyle='#0a0a12'; tc2.fillRect(sx,sy,T,T);
        tc2.fillStyle=wallCol;
        tc2.fillText(h<60?'▓':'▒',sx+T/2,sy+T/2);
      }
      tc2.strokeStyle='#6868a0'; tc2.lineWidth=Math.max(1.2,T*0.065);
      const off=tc2.lineWidth/2;
      const N=r>0?grid[r-1][c]:0,S=r<ROWS-1?grid[r+1][c]:0;
      const W=c>0?grid[r][c-1]:0,E=c<COLS-1?grid[r][c+1]:0;
      if(!N){tc2.beginPath();tc2.moveTo(sx,sy+off);tc2.lineTo(sx+T,sy+off);tc2.stroke();}
      if(!S){tc2.beginPath();tc2.moveTo(sx,sy+T-off);tc2.lineTo(sx+T,sy+T-off);tc2.stroke();}
      if(!W){tc2.beginPath();tc2.moveTo(sx+off,sy);tc2.lineTo(sx+off,sy+T);tc2.stroke();}
      if(!E){tc2.beginPath();tc2.moveTo(sx+T-off,sy);tc2.lineTo(sx+T-off,sy+T);tc2.stroke();}
    }
  }
  const subY=ROWS*T+T*1.4;
  tc2.font=`${Math.max(10,Math.round(T*0.6))}px 'Courier New'`;
  tc2.fillStyle='#2e2e48';
  tc2.fillText('a  top-down  ascii  dungeon  crawler',tc.width/2,subY);
}

drawTitleCanvas();
window.addEventListener('resize',drawTitleCanvas);

// ═══════════════════════════════════════════════════════════════════════
//  FULLSCREEN BUTTON EVENT LISTENERS
// ═══════════════════════════════════════════════════════════════════════
const fullscreenBtn = document.getElementById('fullscreen-btn');
if (fullscreenBtn) {
  fullscreenBtn.addEventListener('click', toggleFullscreen);
  fullscreenBtn.addEventListener('touchend', (e) => { e.preventDefault(); toggleFullscreen(); });
  
  document.addEventListener('fullscreenchange', updateFullscreenButton);
  document.addEventListener('webkitfullscreenchange', updateFullscreenButton);
  document.addEventListener('msfullscreenchange', updateFullscreenButton);
}

</script>
</body>
</html>
